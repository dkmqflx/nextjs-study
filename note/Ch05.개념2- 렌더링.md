## 5.2 최신 버전의 큰 차이점

### v12

- 페이지 단위로 렌더링 방식을 규정

- 페이지 안에서 getStaticProps 사용하면 SSG

- getServerSideProps 사용하면 SSR

- 이러한 것들이 페이지 단위로

### v13

- Server Component 개념이 도입 되었다 (Server Component / Client Component)

  - 서버 상에서만 동작하는 컴포넌트

- 13 버전 부터는 페이지 단위가 아니라 컴포넌트 단위로 렌더링 단위를 규정

- 한 페이지 안에서도 어떤 것은 서버 컴포넌트, 어떤 것은 클라이언트 컴포넌트

- 이런 것 섞어서 효율적으로 페이지 구성할 수 있다

<img src='./images/5-2-1.png'>

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

- 서버 컴포넌트와 클라이언트 컴포넌트 실행되는 환경이 다르니까

  - 서버 컴포넌트 : 서버

  - 클라이언트 컴포넌트 : 클라이언트

- 서로 할 수 있는 것과 없는 것이 다르다

---

## 5.3 서버 컴포넌트

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

  - 실제로 app/page.tsx에서 `console.log('hello');` 하면, 브라우저가 아닌 터미널에서 출력된다

- 서버에서 빌드가 될때 실행이되고, HTML 형태로 브라우저에 전달된다

  - 또는 fethcing을 사용해서 SSR로 한다면 요청시에 서버에서 실행된다

- 서버에서 동작하기 때문에 브라우저에서 제공하는 api는 사용할 수 없고

- 노드 환경에서 제공하는 노드 api는 사용할 수 있다

```js
// app/page.tsx

export default function Home() {
  // 모두 터미널에서만 출력된다
  console.log('hello');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 그렇기 때문에 상태 관련된 것 사용할 수 없다

- 컴파일 관련 에러 발생한다

```js
// app/page.tsx

export default function Home() {
  // 에러 발생
  const [state, setState] = useState();

  console.log('hello - 서버 컴포넌트');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 서버 컴포넌트와 클라이언트에서 할 수 있는 것과 없는 것 구분해야 한다

---

## 5.4 클라이언트 컴포넌트

- 클릭 이벤트 처리하는 것 같이 정말 필요한 부분만 컴포넌트으로 만들어서 처리한다

---

## 5.5 5.5 동작 원리 분석 😎

```shell

$ yarn build

```

- 서버 컴포넌트, 클라이언트 컴포넌트 모두 로그가 출력이 된다

- 네트워크 탭에서 html 문서 파일 보면, 클라이언트 컴포넌트에 해당하는 Counter 부분도 문서에 있는 것을 확인할 수 이다

- 이를 통해 클라이언트 컴포넌트가 무조건 클라이언트 사이드 렌더링 되는 것이 아니라

  - 사용자 클릭 처리 같은, 브라우저에서 실행 되어야 하는 코드를 클라이언트 컴포넌트라고 하고

  - 클라이언트에 보내지는 것을 클라이언트 컴포넌트라고 한다

- html 문서 파일에서 Counter 증가 시키기 위한 버튼 눌러도 아무일도 일어나지 않는다

  - 즉, 클릭 이벤트는 처리되지 않는다

  - 하이드레이션이 일어나야 한다.

- app 폴더 내에서 페이지 만들고 서버 컴포넌트와 클라이언트 컴포넌트로 각각 만들 수 있다

- 클라이언트 컴포넌트라도 라도 빌드를 하면 정적으로 만들 수 있는 부분은 html로 만들어서 사용자에게 보내준다

  - 그렇기 때문에 터미널에서 클라이언트 컴포넌트에 있는 로그가 찍힌 것

  - 클라이언트 컴포넌트를 실행되기 위한 js 코드가 보내지면 그 때 이벤트 같은 것들을 처리할 수 있게 되는 것이다

- 정리하면 v13에서는 페이지 전체 코드가 다 가는 것이 아니라 서버 컴포넌트 부분은 서버에서 실행되어 html 상태로 남아있고

  - v12 까지는 페이지 단위로 처리를 해주었다

- 즉, 클라이언트 컴포넌트를 위한 부분적인 코드만 보내지는 것이다

- 그렇기 때문에 번들이되는 js 코드도 작아지는 것

- html만 받으면 그냥 html 파일이고 브라우저에서 클릭을 해도 처리가 되지 않겠지만 js 코드들을 받는 순간, 리액트 컴포넌트가 되고 이벤트 같은 것들도 처리가 된다

---

## 5.6 공식 사이트 읽기 ✍️

- [https://beta.nextjs.org/docs/rendering/fundamentals](https://beta.nextjs.org/docs/rendering/fundamentals)

### Rendering Fundamentals

- Rendering Environments

  - There are two environments where your application code can be rendered: the client and the server.

  - The client refers to the browser on a user’s device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.

  - The server refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

- Component-level Client and Server Rendering

  - Next.js provided an easier way to break down your application into pages and prerender on the server by generating HTML and sending it to the client to be hydrated by React.

  - However, this led to additional JavaScript needed on the client to make the initial HTML interactive.

  - Now, with Server and Client Components, React can render on the client and the server meaning you can choose the rendering environment at the component level.

  - By default, the app directory uses Server Components, allowing you to easily render components on the server and reducing the amount of JavaScript sent to the client.

    - Server Components에는 클라이언트에 보낼 코드가 없기 때문에 클라이언트에 보내지는 js 파일 크기를 줄일 수 있다

- Server and Client components are rendered differently during Static Rendering:

  - Client Components have their HTML and JSON prerendered and cached on the server.

  - The cached result is then sent to the client for hydration.
    Server Components are rendered on the server by React, and their payload is used to generate HTML.

  - The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.

### Server and Client Components

- Server and Client Components allow developers to build applications that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering.

- Why Server Components?

  - Server Components allow developers to better leverage server infrastructure.

  - For example, large dependencies that previously would impact the JavaScript bundle size on the client can instead remain entirely on the server, leading to improved performance.

  - Server Components make writing a React application feel similar to PHP or Ruby on Rails, but with the power and flexibility of React for templating UI.

  - With Server Components, the initial page load is faster, and the client-side JavaScript bundle size is reduced.

  - The base client-side runtime is cacheable and predictable in size, and does not increase as your application grows.

  - Additional JavaScript is only added as client-side interactivity is used in your application through Client Components.

- Client Components

  - Client Components enable you to add client-side interactivity to your application.

  - In Next.js, they are prerendered on the server and hydrated on the client. You can think of Client Components as how components in the Next.js pages/ directory have always worked.

- [언제 Server Component, Client Component 쓰는지 ](https://beta.nextjs.org/docs/rendering/server-and-client-components#when-to-use-server-vs-client-components)

---

## 5.12 공식 사이트 읽기 ✍️

### Data Fetching Fundamentals

- The Next.js App Router introduces a new, simplified data fetching system built on React and the Web platform.

- This page will go through the fundamental concepts and patterns to help you manage your data's lifecycle.

- Here's a quick overview of the recommendations on this page:

1. Fetch data on the server using Server Components.

2. Fetch data in parallel to minimize waterfalls and reduce loading times.

3. For Layouts and Pages, fetch data where it's used. Next.js will automatically dedupe requests in a tree.

4. Use Loading UI, Streaming and Suspense to progressively render a page and show a result to the user while the rest of the content loads.

- Fetching Data on the Server

  - Whenever possible, we recommend fetching data inside Server Components.

  - Server Components always fetch data on the server. This allows you to:

    - 문서 참고

- [Parallel and Sequential Data Fetching](https://beta.nextjs.org/docs/data-fetching/fundamentals#component-level-data-fetching)

  - 병렬적으로 처리하는 것이 더 좋다

- [Automatic fetch() Request Deduping](https://beta.nextjs.org/docs/data-fetching/fundamentals#component-level-data-fetching)

  - 여러 페이지에서 중복적으로 사용되는 컴포넌트 있어서 중복적된 동일한 요청되더라도 Next.js에서 알아서 자동으로 중복제거를 해서 유일한 요청 하나하나만 남긴다

  - POST requests are not automatically deduplicated.

    - 주의할 것은 POST 요쳥 같은 경우에는 중복 제거를 해주지 않는다

--

- Next.js 사용하면 풀스택 가능한데 이걸 가능하게 해주는 것이 api 폴더

- 별도의 서버 없어도 api에 있는 함수를 vercel에 등록하면 서버처럼 작동한다

- 서비스에서 제품에 대한 것 읽어와서, 클라이언트 사이드 코드에서 백엔드 서버처럼 사용할 수 있다

--

## 5.15 커뮤니티에 기여 하기 😊

- [Route Handlers](https://beta.nextjs.org/docs/routing/route-handlers)

- 기존에는 이런식으로 조건문으로 처리 해주어야 했는데

```js
export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  if (req.method === 'GET') {
    res.status(200).json({ name: 'John Doe' });
  }
}
```

- 요청별로 함수를 개별적으로 만들 수 있다

```js
import { NextResponse } from 'next/server';

export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return NextResponse.json({ data });
}
```

---

##

- 아래처럼 최신버전으로 업데이트 해주어야 한다

```shell

$ yarn add next@canary

```
