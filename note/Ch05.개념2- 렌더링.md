## 5.2 최신 버전의 큰 차이점

### v12

- 페이지 단위로 렌더링 방식을 규정

- 페이지 안에서 getStaticProps 사용하면 SSG

- getServerSideProps 사용하면 SSR

- 이러한 것들이 페이지 단위로 규정이 되었다.

### v13

- 페이지 단위가 아니라 Server Component 개념이 도입 되었다 (Server Component / Client Component)

  - 서버 상에서만 동작하는 컴포넌트

- 13 버전 부터는 페이지 단위가 아니라 컴포넌트 단위로 렌더링 단위를 규정

- 한 페이지 안에서도 어떤 것은 서버 컴포넌트, 어떤 것은 클라이언트 컴포넌트

- 이런 것 섞어서 효율적으로 페이지 구성할 수 있다

<img src='./images/5-2-1.png'>

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

- 서버 컴포넌트와 클라이언트 컴포넌트 실행되는 환경이 다르니까

  - 서버 컴포넌트 : 서버

  - 클라이언트 컴포넌트 : 클라이언트

- 서로 할 수 있는 것과 없는 것이 다르다

---

## 5.3 서버 컴포넌트

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

  - 실제로 app/page.tsx에서 `console.log('hello');` 하면, 브라우저가 아닌 터미널에서 출력된다

- 서버에서 빌드가 될때 실행이되고, HTML 형태로 브라우저에 전달된다

  - 또는 fetching을 사용해서 SSR로 한다면 요청시에 서버에서 실행된다

- 서버에서 동작하기 때문에 브라우저에서 제공하는 api는 사용할 수 없고

- 노드 환경에서 제공하는 노드 api는 사용할 수 있다

```js
// app/page.tsx
import os from 'os' // 노드 API

export default function Home() {
  // 모두 터미널에서만 출력된다
  console.log('hello');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 그렇기 때문에 상태 관련된 것 사용할 수 없다

- 컴파일 관련 에러 발생한다

```js
// app/page.tsx

export default function Home() {
  // 에러 발생
  const [state, setState] = useState();

  console.log('hello - 서버 컴포넌트');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 서버 컴포넌트와 클라이언트에서 할 수 있는 것과 없는 것 구분해야 한다


### Q. Next.js의 웹 서비스 구조

- 강의를 듣다보니 next.js로 서비스시 웹 서비스의 구조가 의문이 듭니다.

- spa의 경우 최초 문서를 주는 서버인 next.js서버에서 파일을 받아온 이후에는 api서버로 직접 통신하고 ssr은 경우에는 문서랑 파일 받아와도 next.js 서버를 거쳐서 api 통신을 하는 것인가요?

- 그리고 이렇게 구성하게되면 next.js는 route53 - cloud front - s3 에 넣으면 안되는 것인가요?

- 사실 뭐가 뭔지 제가 뭘 모르는지도 모르겠어서 next.js + 스프링부트(api) 사용한다고 가정했을때 웹 서비스 구조가 어떻게 그려지는지 알고싶습니다.

### A. 

- 배포된 프로젝트가 Vercel에서 어떻게 운영되는지 미스테리였어요. 왜냐, Vercel에서 명확하게 내부적으로 어떻게 서버 코드를 동작하는지 문서화 해두지 않았거든요.

- 그런데, 최근에 작성된 이 글에 어떻게 운영되는지 명시해 주고 있습니다 :)

- [Framework-defined infrastructure](https://vercel.com/blog/framework-defined-infrastructure#applying-framework-defined-infrastructure)

---

## 5.4 클라이언트 컴포넌트

- 클릭 이벤트 처리하는 것 같이 정말 필요한 부분만 컴포넌트으로 만들어서 처리한다

- 아래처럼 'use client'를 선언해주어야 한다

```jsx

'use client'

```

- 그렇기 때문에 페이지 전체를 'use client'를 선언해주는 것이 아니라, 정말 필요한 컴포넌트만 'use client'를 선언해주도록 한다

- src/components 폴더 내에 컴포넌트를 만들고, 컴포넌트 내부에 useState 같은 hook 또는 브라우저 이벤트 리스터 같은 것들을 선언해주는 경우에는 src/app에서 import해서 불러와서 그냥 사용하면 에러가 발생한다

- 따라서 이때 'use client'를 컴포넌트 상단에 선언해서 클라이언트 컴포넌트라는 것을 명시해주어야 한다.

- 클라이언트 컴포넌트도 정적인 부분이 서버에서 pre-rendering되지만,

- 대신 렌더링 및 사용자 이벤트 처리를 위한 코드도 클라이언트(브라우저)로 보내져서 클라이언트 상에서 다시 하이드레이션 된답니다. 
---

## 5.5 동작 원리 분석 😎

- Chapter04 폴더 파일을 기준으로 한다

```shell

$ yarn build

```

- 서버 컴포넌트, 클라이언트 컴포넌트 console.log로 작성되어 있는 부분이 모두 빌드 후 로그로 출력이 된다

- 네트워크 탭에서 html 문서 파일 보면, 클라이언트 컴포넌트에 해당하는 Counter 부분도 문서에 있는 것을 확인할 수 이다

- 이를 통해 클라이언트 컴포넌트가 무조건 클라이언트 사이드 렌더링 되는 것이 아니라

  - 사용자 클릭 처리 같은, 브라우저에서 실행 되어야 하는 코드를 클라이언트 컴포넌트라고 하고

  - 클라이언트에 보내지는 것을 클라이언트 컴포넌트라고 한다

- html 문서 파일에서 Counter 증가 시키기 위한 버튼 눌러도 아무일도 일어나지 않는다

  - 즉, 클릭 이벤트는 처리되지 않는다

  - 하이드레이션이 일어나야 한다.

- app 폴더 내에서 페이지 만들고 서버 컴포넌트와 클라이언트 컴포넌트로 각각 만들 수 있다

- 클라이언트 컴포넌트라도 라도 빌드를 하면 정적으로 만들 수 있는 부분은 html로 만들어서 사용자에게 보내준다

  - 그렇기 때문에 터미널에서 클라이언트 컴포넌트에 있는 로그가 찍힌 것

  - 클라이언트 컴포넌트를 실행되기 위한 js 코드가 보내지면 그 때 이벤트 같은 것들을 처리할 수 있게 되는 것이다

- 정리하면 v13에서는 페이지 전체 코드가 다 가는 것이 아니라 서버 컴포넌트 부분은 서버에서 실행되어 html 상태로 남아있고

  - v12 까지는 페이지 단위로 처리를 해주었다

- 즉, 클라이언트 컴포넌트를 위한 부분적인 코드만 보내지는 것이다

- 그렇기 때문에 번들이되는 js 코드도 작아지는 것

- html만 받으면 그냥 html 파일이고 브라우저에서 클릭을 해도 처리가 되지 않겠지만 js 코드들을 받는 순간, 리액트 컴포넌트로 변환이 되고 이벤트 같은 것들도 처리가 된다

- React dev tools에 가면 컴포넌트들이 있는 것을 확인할 수 있다.

- SSG가 필요한 부분은 서버컴포넌트로 작성.

- 즉, 클라이언트의 동작이 필요한 부분은 클라컴포넌트로 작성한다

  - 클라이언트 컴포넌트가 브라우져에서 전달된 후 적용된 형태를 들여다 보았습니다.
    
  - 그 과정에서 클라컴포넌트 전체가 다 번들링 형태의 자바크스립트 방식으로 전달되는게 아니라,

  - next.js는 집요하게, 처음 html으로 뺼 수 있는 부분을 찾아서 프리렌더링하여 추려낸다는 것을 알 수 있었습니다.



따라서 번들링되는 클라 컴포넌트는 렌더링에 관련한 코드는 제외될 것이므로 번들링 파일의 총 용량이 적어질 것 임을 기대할 수 있습니다. "

---

## 5.6 공식 사이트 읽기 ✍️

- [https://beta.nextjs.org/docs/rendering/fundamentals](https://beta.nextjs.org/docs/rendering/fundamentals)

### Rendering Fundamentals

- Rendering Environments

  - There are two environments where your application code can be rendered: the client and the server.

  - The client refers to the browser on a user’s device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.

  - The server refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

- Component-level Client and Server Rendering

  - Next.js provided an easier way to break down your application into pages and prerender on the server by generating HTML and sending it to the client to be hydrated by React.

  - However, this led to additional JavaScript needed on the client to make the initial HTML interactive.

  - Now, with Server and Client Components, React can render on the client and the server meaning you can choose the rendering environment at the component level.

  - By default, the app directory uses **Server Components**, allowing you to easily render components on the server and reducing the amount of JavaScript sent to the client.

    - Server Components에는 클라이언트에 보낼 코드가 없기 때문에 클라이언트에 보내지는 js 파일 크기를 줄일 수 있다

- Server and Client components are rendered differently during Static Rendering:

  - Client Components have their HTML and JSON prerendered and cached on the server.

  - The cached result is then sent to the client for hydration.
    Server Components are rendered on the server by React, and their payload is used to generate HTML.

  - The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.

- 서버 컴포넌트 안에서 클라이언트 컴포넌트, 서버 컴포넌트 가질 수 있고

- 그 안의 클라이언트 컴포넌트 또는 서버 컴포넌트에서도 또 다른 클라이언트 컴포넌트, 서버 컴포넌트 가질 수 있다.

### Server and Client Components

- Server and Client Components allow developers to build applications that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering.

- Why Server Components?

  - Server Components allow developers to better leverage server infrastructure.

  - For example, large dependencies that previously would impact the JavaScript bundle size on the client can instead remain entirely on the server, leading to improved performance.

  - Server Components make writing a React application feel similar to PHP or Ruby on Rails, but with the power and flexibility of React for templating UI.

  - With Server Components, the initial page load is faster, and the client-side JavaScript bundle size is reduced.

  - The base client-side runtime is cacheable and predictable in size, and does not increase as your application grows.

  - Additional JavaScript is only added as client-side interactivity is used in your application through Client Components.

- Client Components

  - Client Components enable you to add client-side interactivity to your application.

  - In Next.js, they are prerendered on the server and hydrated on the client. You can think of Client Components as how components in the Next.js pages/ directory have always worked.

- [언제 Server Component, Client Component 쓰는지 - When to use Server and Client Components?](https://nextjs.org/docs/getting-started/react-essentials#why-server-components)

---

## 5.12 공식 사이트 읽기 ✍️

### Data Fetching Fundamentals

- The Next.js App Router introduces a new, simplified data fetching system built on React and the Web platform.

- This page will go through the fundamental concepts and patterns to help you manage your data's lifecycle.

- Here's a quick overview of the recommendations on this page:

1. Fetch data on the server using Server Components.

2. Fetch data in parallel to minimize waterfalls and reduce loading times.

3. For Layouts and Pages, fetch data where it's used. Next.js will automatically dedupe requests in a tree.

4. Use Loading UI, Streaming and Suspense to progressively render a page and show a result to the user while the rest of the content loads.

- Fetching Data on the Server

  - Whenever possible, we recommend fetching data inside Server Components.

  - Server Components always fetch data on the server. This allows you to:

    - 문서 참고

- [Parallel and Sequential Data Fetching](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#parallel-and-sequential-data-fetching)

  - 병렬적으로 처리하는 것이 더 좋다

- [Automatic fetch() Request Deduping](https://beta.nextjs.org/docs/data-fetching/fundamentals#component-level-data-fetching)

  - 여러 페이지에서 중복적으로 사용되는 컴포넌트 있어서 중복적된 동일한 요청되더라도 Next.js에서 알아서 자동으로 중복제거를 해서 유일한 요청 하나하나만 남긴다

  - POST requests are not automatically deduplicated.

    - 주의할 것은 POST 요쳥 같은 경우에는 중복 제거를 해주지 않는다

--

- Next.js 사용하면 풀스택 가능한데 이걸 가능하게 해주는 것이 api 폴더

- 별도의 서버 없어도 api에 있는 함수를 vercel에 등록하면 서버처럼 작동한다

- 서비스에서 제품에 대한 것 읽어와서, 클라이언트 사이드 코드에서 백엔드 서버처럼 사용할 수 있다

--

## 5.15 커뮤니티에 기여 하기 😊

- [Route Handlers](https://beta.nextjs.org/docs/routing/route-handlers)

- 기존에는 이런식으로 조건문으로 처리 해주어야 했는데

```js
export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  if (req.method === 'GET') {
    res.status(200).json({ name: 'John Doe' });
  }
}
```

- 요청별로 함수를 개별적으로 만들 수 있다

```js
import { NextResponse } from 'next/server';

export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return NextResponse.json({ data });
}
```

---

##

- 아래처럼 최신버전으로 업데이트 해주어야 한다

```shell

$ yarn add next@canary

```
