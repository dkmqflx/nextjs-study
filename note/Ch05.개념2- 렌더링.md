## 5.2 최신 버전의 큰 차이점

### v12

- 페이지 단위로 렌더링 방식을 규정

- 페이지 안에서 getStaticProps 사용하면 SSG

- getServerSideProps 사용하면 SSR

- 이러한 것들이 페이지 단위로

### v13

- Server Component 개념이 도입 되었다 (Server Component / Client Component)

  - 서버 상에서만 동작하는 컴포넌트

- 13 버전 부터는 페이지 단위가 아니라 컴포넌트 단위로 렌더링 단위를 규정

- 한 페이지 안에서도 어떤 것은 서버 컴포넌트, 어떤 것은 클라이언트 컴포넌트

- 이런 것 섞어서 효율적으로 페이지 구성할 수 있다

<img src='./images/5-2-1.png'>

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

- 서버 컴포넌트와 클라이언트 컴포넌트 실행되는 환경이 다르니까

  - 서버 컴포넌트 : 서버

  - 클라이언트 컴포넌트 : 클라이언트

- 서로 할 수 있는 것과 없는 것이 다르다

---

## 5.3 서버 컴포넌트

- app 폴더 안에 있는 모든 컴포넌트는 기본적으로 모두 서버 컴포넌트

  - 별도로 설정하지 하지 않는 이상 모두 서버에서 실행된다

  - 실제로 app/page.tsx에서 `console.log('hello');` 하면, 브라우저가 아닌 터미널에서 출력된다

- 서버에서 빌드가 될때 실행이되고, HTML 형태로 브라우저에 전달된다

  - 또는 fethcing을 사용해서 SSR로 한다면 요청시에 서버에서 실행된다

- 서버에서 동작하기 때문에 브라우저에서 제공하는 api는 사용할 수 없고

- 노드 환경에서 제공하는 노드 api는 사용할 수 있다

```js
// app/page.tsx

export default function Home() {
  // 모두 터미널에서만 출력된다
  console.log('hello');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 그렇기 때문에 상태 관련된 것 사용할 수 없다

- 컴파일 관련 에러 발생한다

```js
// app/page.tsx

export default function Home() {
  // 에러 발생
  const [state, setState] = useState();

  console.log('hello - 서버 컴포넌트');
  console.log(os.hostname());
  return <h1>페이지</h1>;
}
```

- 서버 컴포넌트와 클라이언트에서 할 수 있는 것과 없는 것 구분해야 한다

---

## 5.4 클라이언트 컴포넌트

- 클릭 이벤트 처리하는 것 같이 정말 필요한 부분만 컴포넌트으로 만들어서 처리한다

---

## 5.5 5.5 동작 원리 분석 😎

```shell

$ yarn build

```

- 서버 컴포넌트, 클라이언트 컴포넌트 모두 로그가 출력이 된다

- 네트워크 탭에서 html 문서 파일 보면, 클라이언트 컴포넌트에 해당하는 Counter 부분도 문서에 있는 것을 확인할 수 이다

- 이를 통해 클라이언트 컴포넌트가 무조건 클라이언트 사이드 렌더링 되는 것이 아니라

  - 사용자 클릭 처리 같은, 브라우저에서 실행 되어야 하는 코드를 클라이언트 컴포넌트라고 하고

  - 클라이언트에 보내지는 것을 클라이언트 컴포넌트라고 한다

- html 문서 파일에서 Counter 증가 시키기 위한 버튼 눌러도 아무일도 일어나지 않는다

  - 즉, 클릭 이벤트는 처리되지 않는다

  - 하이드레이션이 일어나야 한다.

- app 폴더 내에서 페이지 만들고 서버 컴포넌트와 클라이언트 컴포넌트로 각각 만들 수 있다

- 클라이언트 컴포넌트라도 라도 빌드를 하면 정적으로 만들 수 있는 부분은 html로 만들어서 사용자에게 보내준다

  - 그렇기 때문에 터미널에서 클라이언트 컴포넌트에 있는 로그가 찍힌 것

  - 클라이언트 컴포넌트를 실행되기 위한 js 코드가 보내지면 그 때 이벤트 같은 것들을 처리할 수 있게 되는 것이다

- 정리하면 v13에서는 페이지 전체 코드가 다 가는 것이 아니라 서버 컴포넌트 부분은 서버에서 실행되어 html 상태로 남아있고

  - v12 까지는 페이지 단위로 처리를 해주었다

- 즉, 클라이언트 컴포넌트를 위한 부분적인 코드만 보내지는 것이다

- 그렇기 때문에 번들이되는 js 코드도 작아지는 것

- html만 받으면 그냥 html 파일이고 브라우저에서 클릭을 해도 처리가 되지 않겠지만 js 코드들을 받는 순간, 리액트 컴포넌트가 되고 이벤트 같은 것들도 처리가 된다

---

## 5.6 공식 사이트 읽기 ✍️

- [https://beta.nextjs.org/docs/rendering/fundamentals](https://beta.nextjs.org/docs/rendering/fundamentals)

### Rendering Fundamentals

- Rendering Environments

  - There are two environments where your application code can be rendered: the client and the server.

  - The client refers to the browser on a user’s device that sends a request to a server for your application code. It then turns the response from the server into an interface the user can interact with.

  - The server refers to the computer in a data center that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.

- Component-level Client and Server Rendering

  - Next.js provided an easier way to break down your application into pages and prerender on the server by generating HTML and sending it to the client to be hydrated by React.

  - However, this led to additional JavaScript needed on the client to make the initial HTML interactive.

  - Now, with Server and Client Components, React can render on the client and the server meaning you can choose the rendering environment at the component level.

  - By default, the app directory uses Server Components, allowing you to easily render components on the server and reducing the amount of JavaScript sent to the client.

    - Server Components에는 클라이언트에 보낼 코드가 없기 때문에 클라이언트에 보내지는 js 파일 크기를 줄일 수 있다

- Server and Client components are rendered differently during Static Rendering:

  - Client Components have their HTML and JSON prerendered and cached on the server.

  - The cached result is then sent to the client for hydration.
    Server Components are rendered on the server by React, and their payload is used to generate HTML.

  - The same rendered payload is also used to hydrate the components on the client, resulting in no JavaScript needed on the client.

### Server and Client Components

- Server and Client Components allow developers to build applications that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering.

- Why Server Components?

  - Server Components allow developers to better leverage server infrastructure.

  - For example, large dependencies that previously would impact the JavaScript bundle size on the client can instead remain entirely on the server, leading to improved performance.

  - Server Components make writing a React application feel similar to PHP or Ruby on Rails, but with the power and flexibility of React for templating UI.

  - With Server Components, the initial page load is faster, and the client-side JavaScript bundle size is reduced.

  - The base client-side runtime is cacheable and predictable in size, and does not increase as your application grows.

  - Additional JavaScript is only added as client-side interactivity is used in your application through Client Components.

- Client Components

  - Client Components enable you to add client-side interactivity to your application.

  - In Next.js, they are prerendered on the server and hydrated on the client. You can think of Client Components as how components in the Next.js pages/ directory have always worked.

- [언제 Server Component, Client Component 쓰는지 ](https://beta.nextjs.org/docs/rendering/server-and-client-components#when-to-use-server-vs-client-components)
