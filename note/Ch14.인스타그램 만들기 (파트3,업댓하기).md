## 14.2 SWR 이해하기

- 꼭 한번 읽어보기

  - https://swr.vercel.app/ko/docs/advanced/understanding

- Fetch and Revalidate

  - Revalidate에서는 isValidating만 true가 된다

- Key Change

  - key가 변경되면 isLoading, isValidating 모두 true가 된다

<img src='./images/14-1-1.png'>

- 두번째 요청을 하게 되면 stale한 것 보여주면서 백그라운드 상으로는 다시 서버에 요청해서 캐시된 데이터를 업데이트 한다

- 만약 변경사항이 없다면 UI 그대로 보이겠지만 변경사항이 있다면 UI가 업데이트 되는 것을 확인할 수 있다

---

## 14.3 좋아요 토글하기❓

- https://www.sanity.io/docs/js-client

- https://next-auth.js.org/configuration/callbacks

- https://swr.vercel.app/docs/mutation

---

## 14.4 좋아요💡- 토글버튼

### Q.

- 음.. 개념이 헷갈리는 거 같은데 우선 제 생각에는 ActionBar 컴포넌트 'use client' 로 클라이언트로 지정해야하지 않나? 생각이 드는데.. 에러가 안나는거보니 아직 개념이 부족한거 같습니다.

- 그래서 궁금한 내용은 ActionBar 컴포넌트는 상태를 가지고 있기 때문에 클라이언트 컴포넌트로 사용해야하지 않나? 생각이 듭니다.

- 근데 해당 강의 내용에서는 그렇지 않아서? 클라이언트로 사용하지 않아도 되는 이유와? 서버 컴포넌트?에서 상태를 사용하는데 에러가 발생하지 않는 이유도 궁금하네요ㅠㅠ

### A.

- 어떤 컴포넌트가 서버 컴포넌트인지 클라이언트 컴포넌트인지는 컴포넌트 파일에 "use client" 선언 여부에 따라서 결정되는 것이 아닙니다.

- 어떤 페이지에 여러 컴포넌트들이 중첩되어 있을 때 "use client"는 "use client"를 선언한 컴포넌트를 포함해서 자식(자손) 컴포넌트들을 모두 클라이언트 컴포넌트로 간주하겠다는 일종의 선언과 같습니다.

- ActionBar 컴포넌트를 사용하는 컴포넌트들에 대한 의존성 그래프를 그려보면 다음과 같습니다.

```shell
PostListCard -> ActionBar

PostListCard -> PostDetail -> ActionBar

PostGridCard -> PostDetail -> ActionBar
```

- PostListCard 파일과 PostGridCard 파일에는 모두 "use client"가 선언되어 있습니다. 따라서 그 자식(자손) 컴포넌트인 ActionBar 는 자동으로 클라이언트 컴포넌트로써 동작하게 됩니다.

- 아래 공식 문서를 읽어보시면 좀 더 이해하시는데 도움이 되실 것 같습니다.

  - https://beta.nextjs.org/docs/rendering/server-and-client-components

- 클라이언트 컴포넌트의 자식 컴포넌트로 서버 컴포넌트가 올 수 있는 이유는 해당 클라이언트 컴포넌트의 children props로 들어갔기 때문입니다.

  - https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components
