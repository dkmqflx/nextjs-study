## 6.2 로딩 UI

- loading.js: Create loading UI for a segment and its children. loading.js wraps a page or child segment in a React Suspense Boundary, showing the loading UI while they load.

- [Loading UI](https://beta.nextjs.org/docs/routing/loading-ui)

- 코드 수정 후 build 한 다음에 네트워크 탭에서 html 파일 확인해보면 getProducts로 비동기적으로 받아오는 부분이 모두 데이터가 있는 것을 확인할 수 있다

- page는 revalidate를 하지 않는 SSG이기 때문에

- SSR인 경우에는 의미가 있지만,

- loading.js 다이나믹하게 SSR로 페이지를 보내주면 의미가 있지만 SSG인 경우 큰 의미가 없다

  - 즉 build 후 start 해보면 로딩중 텍스트가 안보인다

---

## 6.3 병렬적으로 수행 ✍️

- [Loading UI](https://beta.nextjs.org/docs/routing/loading-ui)

- Next.js 13 introduced a new file convention, loading.js, to help you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment loads, the new content is automatically swapped in once rendering is complete.

- In the same folder, loading.js will be nested inside layout.js.

- It'll wrap the page.js file and any children below in a `<Suspense>` boundary.

- loading 사용하기 편하지만 한계점은, 해당 경로, 라우트에 한번만 정의할 수 있다. 그렇기 때문에 부분적으로 로딩 상태 나타내기 위해서 Suspense 사용할 수 있다

- [Data Fetching Patterns](https://beta.nextjs.org/docs/data-fetching/fetching#parallel-data-fetching)

  - async/await 대신 Promise.all 사용해서 병렬적으로 처리할 수 있다

  - 하지만, 이렇게 처리하면,

  - We can save time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved.

  - 이 때 사용할 수 있는 것이 suspense boundary

```js
// ...

export default async function Page({ params: { username } }) {
  // Initiate both requests in parallel
  const artistData = getArtist(username);
  const albumData = getArtistAlbums(username);

  // Wait for the artist's promise to resolve first
  const artist = await artistData;

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Send the artist information first,
      and wrap albums in a suspense boundary */}
      <Suspense fallback={<div>Loading...</div>}>
        <Albums promise={albumData} />
      </Suspense>
    </>
  );
}

// Albums Component
async function Albums({ promise }) {
  // Wait for the albums promise to resolve
  const albums = await promise;

  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>{album.name}</li>
      ))}
    </ul>
  );
}
```

---

## 6.4 에러 UI

- error.js: Create error UI for a segment and its children.

- error.js wraps a page or child segment in a React Error Boundary, showing the error UI if an error is caught.

- [Error Handling](https://beta.nextjs.org/docs/routing/error-handling)

  - Error components must be Client components

---

## 6.8 폰트

- 폰트를 다운로드 받은 다음에 적용된 포트를 보여준다

- 기본 폰트 사이즈가 적용되는 폰트와 다르기 때문에 layout shift가 나타날 수 있고

- 외부 서버에 요청해서 폰트를 다운로드 받아야 하는데

- 이것을 해결할 수 있다

- [Optimizing Fonts](https://beta.nextjs.org/docs/optimizing/fonts)

- next/font includes built-in automatic self-hosting for any font file.

- This means you can optimally load web fonts with zero layout shift, thanks to the underlying CSS size-adjust property used.

- This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind.

- CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser.

- Get started by importing the font you would like to use from next/font/google as a function. We recommend using variable fonts for the best performance and flexibility.

  - variable fonts란 폰트마다 같은 폰트라도 두께, 이탈릭인지 아닌지에 따라 각기 다른 파일들을 다운로드 받아야 하는데, 하나의 파일만으로 다양한 버전을 적용할 수 있는 것
