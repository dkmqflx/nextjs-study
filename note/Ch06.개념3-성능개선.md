## 6.2 로딩 UI

- [Instant Loading States](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)

- loading.js: Create loading UI for a segment and its children. loading.js wraps a page or child segment in a React Suspense Boundary, showing the loading UI while they load.

  - 즉, loading.js 파일을 만들기만해도 Layout의 children에 해당하는 부분을 Suspense의 fallback으로 감싼 것과 동일한 효과를 갖는다

  - 실제로 코드 변경 후 네트워크 탭에서 html 문서를 보면 "로딩중입니다..." 가 있는 것을 확인할 수 있다.

- 하지만, 코드 수정 후 build 한 다음에 네트워크 탭에서 html 파일 확인해보면 getProducts로 비동기적으로 받아오는 부분이 모두 데이터가 있는 것을 확인할 수 있다

- 만약 SSR인 경우에는 loading.js를 사용하는게 의미가 있지만,

- SSG인 경우 큰 의미가 없다

  - 즉 build 후 start 해보면 로딩중 텍스트가 안보인다

---

## 6.3 병렬적으로 수행 ✍️

- [Loading UI](https://beta.nextjs.org/docs/routing/loading-ui)

- Next.js 13 introduced a new file convention, loading.js, to help you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment loads, the new content is automatically swapped in once rendering is complete.

- In the same folder, loading.js will be nested inside layout.js.

- It'll wrap the page.js file and any children below in a `<Suspense>` boundary.

- loading 사용하기 편하지만 한계점은, 해당 경로, 라우트에 한번만 정의할 수 있다. 그렇기 때문에 부분적으로 로딩 상태 나타내기 위해서 Suspense 사용할 수 있다

- 즉, 경로내에 페이지 컴포넌트를 크게 감싸기때문에 중첩 Suspense 구현이 안되기 때문에 page 컴포넌트에 내용을 작은 단위로 분리하여 직접 Suspense API 를 사용하면 된다.

  - [Streaming with Suspense](https://github.com/dkmqflx/nextjs-study/commit/fb8ab5b94ee87dca128f5dcc2d295952f166a2ad)

<br/>

- [Parallel Data Fetching](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#parallel-data-fetching)
  
  - async/await 대신 Promise.all 사용해서 병렬적으로 처리할 수 있다

  - 하지만, 이렇게 처리하면,

  - We can save time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved.

  - 이 때 사용할 수 있는 것이 suspense boundary

```js
// ...

export default async function Page({ params: { username } }) {
  // Initiate both requests in parallel
  const artistData = getArtist(username); // await 사용하지 않고 프로미스 반환한다
  const albumData = getArtistAlbums(username); // await 사용하지 않고 프로미스 반환한다

  // Wait for the artist's promise to resolve first
  const artist = await artistData;

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Send the artist information first,
      and wrap albums in a suspense boundary */}
      <Suspense fallback={<div>Loading...</div>}>
        <Albums promise={albumData} />
      </Suspense>
    </>
  );
}

// Albums Component
async function Albums({ promise }) {
  // Wait for the albums promise to resolve
  const albums = await promise;

  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>{album.name}</li>
      ))}
    </ul>
  );
}
```


- 요약해보자면 이런게 아닐까 싶다
  
- SSR을 사용하게 되면 사용자는 의미있는 화면을 보기까지, 전체 화면이 서버에서 다 만들어질 때까지 기다려야 한다
  
- 그렇기 때문에 loading.js를 만들어서 화면이 만들어지기 전의 fallback 화면을 보게 하자

  - 여기서 네트워크 탭의  html 문서 loading.js에 있는 내용만 있고
 
  - 그 이후에 데이터를 받아와서 화면이 업데이트 된다

- 하지만 loading.js의 page를 감싸는, 너무나 큰 단위이고, 서버에서 전체 화면에 대해 데이터 받아오고, HTML 만들어서 클라이언트로 보내면 그 때 하이드레이션이 일어나기 때문에
  
- 컴포넌트로 나눠서 작게하기 위해서 컴포넌트 단위로 Suspense를 사용하자는 것이 Streaming with Suspense

- [Suspense SSR Architecture in React 18](https://blog.mathpresso.com/suspense-ssr-architecture-in-react-18-ec75e80eb68d)

  - 특정 컴포넌트만 감싸면, 해당 컴포넌트를 제외한 나머지 우선 나머지 컴포넌트 대해 HTML을 Streaming 할 수 있게 된다.

  - 이 상황에서 해당 컴포넌틀르 위한 데이터가 준비되면, 리액트는 동일한 Stream에 추가되는 HTML과, 해당 HTML을 올바른 “위치”에 주입하기 위한 작은 inline “script” 태그를 보내준다.

  - 화면의 일부가 최초 HTML을 보내는 작업을 지연시키면, 해당 파트를 HTML에서 제외할 것인지를 선택할 필요 없이 해당 부분만 HTML 스트리밍 상에 나중에 들어오게 할 수 있다.

  - 어디에 로딩 스피너가 나타날지 정해주면, 리액트가 해당 위치에 Stream으로 script와 함께 컴포넌트를 넣어주기 때문에 데이터가 특별한 순서에 맞춰서 로딩될 필요도 없다.

  -> 그래서 streaming with suspense라고 하는 것인가 ?

-> CSR과 비교해서 생각할 필요가 없는게, CSR은 html로 빈 문서를 받아서 클라이언트에서 js 파일 같은 것을 통해 그려주는데, 위에서 보는 모든 것은 SSR로 동작해서 html 문서를 서버에서 만들어서 보내준다.


---

## 6.4 에러 UI

- [Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling)

- error.js: Create error UI for a segment and its children.

- error.js wraps a page or child segment in a React Error Boundary, showing the error UI if an error is caught.

  - 로딩이 내부적으로 Suspense를 사용한다면, 에러는 Error Boundary를 사용한다 

- Error components must be Client components

- 가장 근접한 곳에 error.js 파일이 없다면, 그 상위 폴더에서 error.js 파일을 계속해서 찾아 나간다

---

## 6.8 폰트

- 폰트를 다운로드 받은 다음에 적용된 포트를 보여준다

- 기본 폰트 사이즈가 적용되는 폰트와 다르기 때문에 layout shift가 나타날 수 있고

- 외부 서버에 요청해서 폰트를 다운로드 받아야 하는데

- 이것을 해결할 수 있다

- [Optimizing Fonts](https://beta.nextjs.org/docs/optimizing/fonts)

- next/font includes built-in automatic self-hosting for any font file.

- This means you can optimally load web fonts with zero layout shift, thanks to the underlying CSS size-adjust property used.

- This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind.

- CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser.

- Get started by importing the font you would like to use from next/font/google as a function. We recommend using variable fonts for the best performance and flexibility.

  - variable fonts란 폰트마다 같은 폰트라도 두께, 이탈릭인지 아닌지에 따라 각기 다른 파일들을 다운로드 받아야 하는데, 하나의 파일만으로 다양한 버전을 적용할 수 있는 것

---

## 6.12 미들웨어

- 로그인해야지 볼 수 있는 페이지들 있다면 모든 페이지에서 각각 인증 관련 로직 구현하는 것은 비효율적

- 공통적으로 수행해야 하는 일을 미들웨어로 만들 수 있다

- 미들웨어는 문지기 같은 것

- 미들웨어는 src 최상위 폴더, src 폴더 없다면 프로젝트 최상위 폴더에 만들어준다
